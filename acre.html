<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <link rel="canonical" href="/acre" />
    <title>Acre</title>
    <link rel="stylesheet" href="/style.css" />
    <link rel="icon" type="image/svg+xml" href="/icon.svg"/>
    <link rel="icon" type="image/png" href="/icon.png"/>
  </head>
  <body>
    <article>
<!-- compiled by markup/main.c -->
<header>
  <div class="block block--breadcrumbs">
    <p><a class="link" href="/">Home</a> »</p>
  </div>
  <div class="block block--title">
    <p>Acre</p>
  </div>
</header>
<p>Acre is a language that doesn’t exist yet.</p>
<h2><a class="heading__link" id="functions" href="#functions">Functions</a></h2>
<p>Functions are defined with the following syntax:</p>
<pre class="codeblock">
<span class="hl__keyword">extern</span> <span class="hl__keyword">func</span> &lt;name&gt;(&lt;arg&gt;: &lt;type&gt;) -&gt; ();
<span class="hl__keyword">func</span> &lt;name&gt;(&lt;arg&gt;: &lt;type&gt;, &lt;arg&gt;: &lt;type&gt;) -&gt; &lt;type&gt; {
    ...body
}
</pre><p>Making functions and constants use the same syntax is attractive, but that either:</p>
<ul>
  <li>
    <p>requires semicolons after function definitions, or</p>
  </li>
  <li>
    <p>requires the parser to allow missing semicolons.</p>
  </li>
</ul>
<h2><a class="heading__link" id="variables" href="#variables">Variables</a></h2>
<pre class="codeblock">
<span class="hl__keyword">def</span> &lt;name&gt; = &lt;value&gt;;
<span class="hl__keyword">def</span> &lt;name&gt;: &lt;type&gt;;
<span class="hl__keyword">def</span> &lt;name&gt;: &lt;type&gt; = &lt;value&gt;;

<span class="hl__keyword">var</span> &lt;name&gt; = &lt;value&gt;;
<span class="hl__keyword">var</span> &lt;name&gt;: &lt;type&gt;;
<span class="hl__keyword">var</span> &lt;name&gt;: &lt;type&gt; = &lt;value&gt;;
</pre><p>Where <code>def</code> is for constants, and <code>var</code> is for variables.</p>
<h2><a class="heading__link" id="types" href="#types">Types</a></h2>
<h3><a class="heading__link" id="built-in-types" href="#built-in-types">Built-in types</a></h3>
<ul>
  <li>
    <p><code>u8</code>, <code>u16</code>, <code>u32</code>, <code>u64</code>, <code>usize</code>: Unsigned integers.</p>
  </li>
  <li>
    <p><code>i8</code>, <code>i16</code>, <code>i32</code>, <code>i64</code>, <code>isize</code>: Signed integers.</p>
  </li>
  <li>
    <p><code>f32</code>, <code>f64</code>: Floating-point numbers.</p>
  </li>
  <li>
    <p><code>opaque</code>: Unsized type.</p>
  </li>
</ul>
<h3><a class="heading__link" id="opaque" href="#opaque">Opaque</a></h3>
<p>The <code>opaque</code> type has no size.</p>
<p>Without the <code>#unique</code> qualifier, any instance of <code>opaque</code> can be casted into any other.</p>
<p>Pointers to <code>opaque</code> may exist, but slices cannot.</p>
<pre class="codeblock">
<span class="hl__keyword">def</span> c_void = <span class="hl__keyword">#unique</span> <span class="hl__type">opaque</span>;
</pre><h3><a class="heading__link" id="unique" href="#unique">Unique</a></h3>
<p>The <code>#unique</code> qualifier can be used to make a type with the same operations and storage as the underlying type, but without implicit casting, either to the underlying type or to any type that the underlying type could be implicitly cast to.</p>
<pre class="codeblock">
<span class="hl__keyword">def</span> utf8_byte = <span class="hl__keyword">#unique</span> <span class="hl__type">u8</span>;
<span class="hl__keyword">def</span> utf8_codepoint = <span class="hl__keyword">#unique</span> <span class="hl__type">u32</span>;
</pre><h3><a class="heading__link" id="tuples" href="#tuples">Tuples</a></h3>
<p>Tuples can be types or values.</p>
<p>They’re created by putting several values in parentheses, with commas separating them.</p>
<p>When creating a tuple of only one element, a comma is required.</p>
<pre class="codeblock">
<span class="hl__keyword">def</span> Vec0 = ();
<span class="hl__keyword">def</span> Vec1 = (<span class="hl__type">f32</span>,);
<span class="hl__keyword">def</span> Vec2 = (<span class="hl__type">f32</span>, <span class="hl__type">f32</span>);
<span class="hl__keyword">def</span> Vec3 = (<span class="hl__type">f32</span>, <span class="hl__type">f32</span>, <span class="hl__type">f32</span>);

<span class="hl__keyword">var</span> my_vec3: Vec3 = (<span class="hl__number">1</span>.<span class="hl__number">0</span>, <span class="hl__number">0</span>.<span class="hl__number">0</span>, <span class="hl__number">1</span>.<span class="hl__number">0</span>);
</pre><p>Tuples with the same structure are implicitly casted between, so:</p>
<pre class="codeblock">
<span class="hl__keyword">def</span> Ipv4Address = (<span class="hl__type">u8</span>, <span class="hl__type">u8</span>, <span class="hl__type">u8</span>, <span class="hl__type">u8</span>);
<span class="hl__keyword">def</span> FourCC = (<span class="hl__type">u8</span>, <span class="hl__type">u8</span>, <span class="hl__type">u8</span>, <span class="hl__type">u8</span>);

<span class="hl__keyword">var</span> address: Ipv4Address = (<span class="hl__number">127</span>, <span class="hl__number">0</span>, <span class="hl__number">0</span>, <span class="hl__number">1</span>);
<span class="hl__keyword">var</span> magic: FourCC = (<span class="hl__number">0x7F</span>, <span class="hl__number">0x45</span>, <span class="hl__number">0x4c</span>, <span class="hl__number">0x46</span>);

address = magic; <span class="hl__comment">// whoops!</span>
</pre><h3><a class="heading__link" id="unit" href="#unit">Unit</a></h3>
<p>The unit type (spelled <code>()</code>, and pronounced <code>()</code>) has one possible value: <code>()</code>. It takes the place of Rust’s <code>()</code> type, or C’s <code>void</code> type.</p>
<h3><a class="heading__link" id="references" href="#references">References</a></h3>
<p>References behave nearly identically to pointers. The only difference is that pointers can be implicitly casted to references, but not the other way around.</p>
<h3><a class="heading__link" id="pointers-and-slices" href="#pointers-and-slices">Pointers and slices</a></h3>
<p>Slices cannot be used directly; they can only be used in pointer form.</p>
<p>Slices can be created from either arrays or pointers-to-unknown.</p>
<pre class="codeblock">
<span class="hl__keyword">var</span> bytes: [<span class="hl__number">4</span>]<span class="hl__type">u8</span> = { <span class="hl__number">0xDE</span>, <span class="hl__number">0xAD</span>, <span class="hl__number">0xBE</span>, <span class="hl__number">0xEF</span> };

<span class="hl__keyword">var</span> dead = bytes[<span class="hl__number">0</span>..<span class="hl__number">2</span>];
<span class="hl__comment">// the type of `dead` is [2]u8</span>

dead[<span class="hl__number">0</span>] = <span class="hl__number">0xBA</span>;

<span class="hl__comment">// without a reference, the slice operator copies the created slice.</span>
assert(bytes[<span class="hl__number">0</span>] == <span class="hl__number">0xDE</span>);

<span class="hl__keyword">var</span> reference = &amp;bytes[<span class="hl__number">0</span>..<span class="hl__number">2</span>];
<span class="hl__comment">// the type of `reference` is &amp;[2]u8</span>
reference[<span class="hl__number">0</span>] = <span class="hl__number">0xBA</span>;
assert(bytes[<span class="hl__number">0</span>] == <span class="hl__number">0xBA</span>); <span class="hl__comment">// with a reference, the backing array can be modified.</span>

<span class="hl__comment">// casts from &amp;[&lt;number&gt;]u8 to &amp;[..]u8 are allowed..</span>
<span class="hl__keyword">var</span> slice: &amp;[..]<span class="hl__type">u8</span> = reference;

<span class="hl__comment">// ..and so are casts from &amp;[..]u8 to &amp;[?]u8</span>
<span class="hl__keyword">var</span> ptr_unknown_length: &amp;[?]<span class="hl__type">u8</span> = reference;
assert(ptr_unknown_length[<span class="hl__number">3</span>] == <span class="hl__number">0xEF</span>);

<span class="hl__keyword">var</span> beef: &amp;[..]<span class="hl__type">u8</span> = &amp;ptr_unknown_length[<span class="hl__number">2</span>..<span class="hl__number">4</span>];
assert(beef[<span class="hl__number">0</span>] == <span class="hl__number">0xBE</span>);
assert(beef[<span class="hl__number">1</span>] == <span class="hl__number">0xEF</span>);

<span class="hl__comment">// casting from a slice to an array is allowed, but safety-checked.</span>
<span class="hl__comment">// this is fine:</span>
<span class="hl__keyword">var</span> two: &amp;[<span class="hl__number">2</span>]<span class="hl__type">u8</span> = beef;

<span class="hl__comment">// but this is a panic:</span>
<span class="hl__keyword">var</span> three: &amp;[<span class="hl__number">3</span>]<span class="hl__type">u8</span> = beef;
</pre><!-- end compiled region -->
    </article>
    <footer>
      <p>copyright © 2024</p>
    </footer>
  </body>
</html>
