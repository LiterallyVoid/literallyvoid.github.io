<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <link rel="canonical" href="/proglang/syntax" />
    <title>Acre’s Syntax</title>
    <link rel="stylesheet" href="/style.css" />
    <link rel="icon" type="image/svg+xml" href="/icon.svg"/>
    <link rel="icon" type="image/png" href="/icon.png"/>
  </head>
  <body>
    <article>
<!-- autogenerated from markup/main.c -->
<header>
  <div class="block block--breadcrumbs">
    <p><a class="link" href="/">Home</a> » <a class="link" href="/proglang">Acre</a></p>
  </div>
  <div class="block block--title">
    <p>Acre’s Syntax</p>
  </div>
</header>
<h2><a class="heading__link" id="functions" href="#functions">Functions</a></h2>
<p>Functions are defined with the following syntax:</p>
<pre class="codeblock">
<span class="hl__keyword">extern</span> <span class="hl__keyword">func</span> &lt;name&gt;(&lt;arg&gt;: &lt;type&gt;) -&gt; ();
<span class="hl__keyword">func</span> &lt;name&gt;(&lt;arg&gt;: &lt;type&gt;, &lt;arg&gt;: &lt;type&gt;) -&gt; &lt;type&gt; {
    ...body
}
</pre><p>I’d like to use universal constant defining, but this either:</p>
<ul>
  <li>
    <p>requires semicolons after function definitions, or</p>
  </li>
  <li>
    <p>requires the parser to allow missing semicolons.</p>
  </li>
</ul>
<h2><a class="heading__link" id="variables" href="#variables">Variables</a></h2>
<pre class="codeblock">
<span class="hl__keyword">def</span> &lt;name&gt; = &lt;value&gt;;
<span class="hl__keyword">def</span> &lt;name&gt;: &lt;type&gt;;
<span class="hl__keyword">def</span> &lt;name&gt;: &lt;type&gt; = &lt;value&gt;;

<span class="hl__keyword">var</span> &lt;name&gt; = &lt;value&gt;;
<span class="hl__keyword">var</span> &lt;name&gt;: &lt;type&gt;;
<span class="hl__keyword">var</span> &lt;name&gt;: &lt;type&gt; = &lt;value&gt;;
</pre><p>Where <code>def</code> is for constants, and <code>var</code> is for variables.</p>
<h2><a class="heading__link" id="types" href="#types">Types</a></h2>
<h3><a class="heading__link" id="built-in-types" href="#built-in-types">Built-in types</a></h3>
<ul>
  <li>
    <p><code>u8</code>, <code>u16</code>, <code>u32</code>, <code>u64</code>, <code>usize</code>: unsigned integers.</p>
  </li>
  <li>
    <p><code>i8</code>, <code>i16</code>, <code>i32</code>, <code>i64</code>, <code>isize</code>: signed integers.</p>
  </li>
</ul>
<h3><a class="heading__link" id="opaque" href="#opaque">Opaque</a></h3>
<p>The <code>opaque</code> type has no size.</p>
<p>Without the <code>#unique</code> qualifier, any instance of <code>opaque</code> can be casted into any other.</p>
<p>Pointers to <code>opaque</code> may exist, but slices cannot.</p>
<pre class="codeblock">
<span class="hl__keyword">def</span> c_void = <span class="hl__keyword">#unique</span> <span class="hl__type">opaque</span>;
</pre><h3><a class="heading__link" id="unique" href="#unique">Unique</a></h3>
<p>The <code>#unique</code> qualifier can be used to make a type with the same operations and storage as the underlying type, but without implicit casting, either to the underlying type or to any type that the underlying type could be implicitly cast to.</p>
<pre class="codeblock">
<span class="hl__keyword">def</span> utf8_byte = <span class="hl__keyword">#unique</span> <span class="hl__type">u8</span>;
<span class="hl__keyword">def</span> utf8_codepoint = <span class="hl__keyword">#unique</span> <span class="hl__type">u32</span>;
</pre><h3><a class="heading__link" id="pairs" href="#pairs">Pairs</a></h3>
<p>Pairs can exist of types and values.</p>
<p>The only way to create pairs is through the comma operator, which is right-associative; so the following are all equivalent:</p>
<pre class="codeblock">
<span class="hl__keyword">def</span> MyPair = <span class="hl__type">i32</span>, <span class="hl__type">i32</span>, <span class="hl__type">i64</span>, <span class="hl__type">i64</span>;
<span class="hl__keyword">def</span> MyPair = (<span class="hl__type">i32</span>, <span class="hl__type">i32</span>, <span class="hl__type">i64</span>, <span class="hl__type">i64</span>);
<span class="hl__keyword">def</span> MyPair = (<span class="hl__type">i32</span>, (<span class="hl__type">i32</span>, (<span class="hl__type">i64</span>, (<span class="hl__type">i64</span>))));
</pre><p>However, this:</p>
<pre class="codeblock">
<span class="hl__keyword">def</span> MyPair = (<span class="hl__type">i32</span>, (<span class="hl__type">i32</span>, <span class="hl__type">i64</span>), <span class="hl__type">i64</span>);
</pre><p>is <em>not</em> equivalent.</p>
<p>Pairs with the same structure are implicitly casted between, so:</p>
<pre class="codeblock">
<span class="hl__keyword">def</span> Ipv4Address = (<span class="hl__type">u8</span>, <span class="hl__type">u8</span>, <span class="hl__type">u8</span>, <span class="hl__type">u8</span>);
<span class="hl__keyword">def</span> FourCC = (<span class="hl__type">u8</span>, <span class="hl__type">u8</span>, <span class="hl__type">u8</span>, <span class="hl__type">u8</span>);

<span class="hl__keyword">var</span> address: Ipv4Address = (<span class="hl__number">12</span>7, 0, 0, 1);
<span class="hl__keyword">var</span> magic: FourCC = (<span class="hl__number">0x7F</span>, <span class="hl__number">0x45</span>, <span class="hl__number">0x4c</span>, <span class="hl__number">0x46</span>);

address = magic; <span class="hl__comment">// whoops!
</span></pre><h3><a class="heading__link" id="pointers-and-slices" href="#pointers-and-slices">Pointers and slices</a></h3>
<p>Slices cannot be used directly, they can only be used in pointer form.</p>
<p>Slices can be created from either arrays or pointer-to-unknown.</p>
<pre class="codeblock">
<span class="hl__keyword">var</span> bytes: [4]<span class="hl__type">u8</span> = { <span class="hl__number">0x</span>DE, <span class="hl__number">0x</span>AD, <span class="hl__number">0x</span>BE, <span class="hl__number">0x</span>EF };

<span class="hl__keyword">var</span> dead = bytes[0..2];
<span class="hl__comment">// the type of `dead` is [2]u8
</span>
dead[0] = <span class="hl__number">0x</span>BA;

<span class="hl__comment">// without a reference, the slice operator copies the created slice.
</span>assert(bytes[0] == <span class="hl__number">0x</span>DE);

<span class="hl__keyword">var</span> reference = &amp;bytes[0..2];
<span class="hl__comment">// the type of `reference` is &amp;[2]u8
</span>reference[0] = <span class="hl__number">0x</span>BA;
assert(bytes[0] == <span class="hl__number">0x</span>BA); <span class="hl__comment">// with a reference, the backing array can be modified.
</span>
<span class="hl__comment">// casts from &amp;[&lt;number&gt;]u8 to &amp;[..]u8 are allowed..
</span><span class="hl__keyword">var</span> slice: &amp;[..]<span class="hl__type">u8</span> = reference;

<span class="hl__comment">// ..and so are casts from &amp;[..]u8 to &amp;[?]u8
</span><span class="hl__keyword">var</span> ptr_unknown_length: &amp;[?]<span class="hl__type">u8</span> = reference;
assert(ptr_unknown_length[3] == <span class="hl__number">0x</span>EF);
</pre><!-- end autogenerated region -->
    </article>
    <footer>
      <p>copyright © 2021</p>
    </footer>
  </body>
</html>
