<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <link rel="canonical" href="/gui" />
    <title></title>
    <link rel="stylesheet" href="/style.css" />
    <link rel="icon" type="image/svg+xml" href="/icon.svg"/>
    <link rel="icon" type="image/png" href="/icon.png"/>
  </head>
  <body>
    <article>
<!-- autogenerated from markup/main.c -->
<header>
  <div class="block block--breadcrumbs">
    <p><a class="link" href="/">Home</a> »</p>
  </div>
  <div class="block block--title">
    <p>How the GUI system works</p>
    <div class="block block--published">
      <p>2021/02/10</p>
    </div>
  </div>
</header>
<h2><a class="heading__link" id="elements" href="#elements">Elements</a></h2>
<p>Any inline element found in the tree, without a current inline context, creates an “inline context” which all inline descendants (and itself) insert boxes into. Each text element can then query the inline context to see if text can fit or must be wrapped.</p>
<p>Box element layouts are influenced by their parents in one way: the size hint. If the size hint is -1 in either axis, that means that the element should have the natural (minimum) size in that axis; otherwise, the element should be exactly sized to the size hint in that axis.</p>
<p>This system allows users to do 90% of what HTML/CSS can do, with 1% of the code and a single pass. No O(n<sup>2</sup>) here!</p>
<p>After all children have been laid out (and sized), the parent element should move them to the correct places.</p>
<p>Pseudocode for the <code>flex</code> element:</p>
<pre>
float total_along = 0;
float total_flex_grow = 0;

box[children.len] boxes;

// layout all minimum-size flex elements
for i, child in children {
    if child.flex_grow != -1 {
        total_flex_grow += child.flex_grow;
        continue;
    }

    vec2 child_size_hint = {
        [primary_axis] = -1,
        [secondary_axis] = size_hint[secondary_axis],
    };
    boxes[i] = child.layout(size_hint = child_size_hint);
}

// layout all growing flex elements
float extra_space = size_hint[primary_axis] - total_along;
for i, child in children {
    if child.flex_grow == -1 {
        continue;
    }
    vec2 child_size_hint = {
        [primary_axis] = extra_space * (child.flex_grow / total_flex_grow),
        [secondary_axis] = size_hint[secondary_axis],
    };
    boxes[i] = child.layout(size_hint = child_size_hint);
}

// move elements to the correct place
float current = 0;
for i, _ in children {
    boxes[i].offset = {
        0, 0,
        [primary_axis] = current,
    };
    current += boxes[i].size[primary_axis];
}</pre>
<!-- end autogenerated region -->
    </article>
    <footer>
      <p>© 2021</p>
    </footer>
  </body>
</html>
